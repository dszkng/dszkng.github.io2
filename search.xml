<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PHP 结构型设计模式</title>
      <link href="/2019/12/03/PHP/"/>
      <url>/2019/12/03/PHP/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h2><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>将截然不同的类/函数，按需要封装成统一的API。<br>比如说 PHP 中操作数据库有3种方式，<code>mysql/mysqli/pdo</code>，这3种的操作函数各不相同，通过适配器模式可以统一成一种操作方式。类似的场景还有缓存，将 <code>file/redis/memcache/apc</code> 等不同的缓存实现统一成一致的。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><h3 id="示例代码1"><a href="#示例代码1" class="headerlink" title="示例代码1"></a>示例代码1</h3><pre><code class="PHP">interface Database{    public function connect($host, $user, $pass, $dbName);    public function query($sql);    public function close();}class MySQL implements Database{    protected $connect;    public function connect($host, $user, $pass, $dbName)    {        $conn = mysql_connect($host, $user, $pass);        mysql_select_db($dbName, $conn);        $this-&gt;connect = $conn;    }    public function query($sql)    {        return mysql_query($sql, $this-&gt;connect);    }    public function close()    {        mysql_close($this-&gt;connect);    }}class MySQLi implements Database{    protected $connect;    public function connect($host, $user, $pass, $dbName)    {        $this-&gt;connect = mysqli_connect($host, $user, $pass, $dbName);    }    public function query($sql)    {        return mysqli_query($this-&gt;connect, $sql);    }    public function close()    {        mysqli_close($this-&gt;connect);    }}class PDO implements Database{    protected $connect;    public function connect($host, $user, $pass, $dbName)    {        $this-&gt;connect = new \PDO(&quot;mysql:host={$host};dbname={$dbName}&quot;, $user, $pass);    }    public function query($sql)    {        return $this-&gt;connect-&gt;query($sql);    }    public function close()    {        unset($this-&gt;connect);    }}// Usage$db = new MySQL(); // new MySQLi()$db-&gt;connect(&#39;127.0.0.1&#39;, &#39;root&#39;, &#39;123456&#39;, &#39;blog&#39;);</code></pre><h3 id="示例代码2"><a href="#示例代码2" class="headerlink" title="示例代码2"></a>示例代码2</h3><pre><code class="PHP">/** * 纸质书接口 * Interface PaperBookInterface */interface PaperBookInterface{    /**     * 打开书的方法     * @return mixed     */    public function open();    /**     * 翻页方法     * @return mixed     */    public function turnPage();}/** * 纸质书接口的一个实现类 * Class Book */class Book implements PaperBookInterface{    public function open()    {        echo &#39;打开纸质书&#39;;    }    public function turnPage()    {        echo &#39;纸质书翻页&#39;;    }}/** * 电子书接口 */interface EBookInterface{    /**     * 打开电子书     * @return mixed     */    public function pressStart();    /**     * 电子书翻页     * @return mixed     */    public function pressNext();}/** * 电子书的一个实现类 */class Kindle implements EBookInterface{    public function pressStart()    {        echo &#39;打开电子书&#39;;    }    public function pressNext()    {        echo &#39;电子书翻页&#39;;    }}/** * EBookAdapter 是电子书适配器类 * * 该适配器实现了纸质书接口, 但是你不必修改客户端（电子书类/接口）的方法就可以使用纸质书的访问代码 */class EBookAdapter implements PaperBookInterface{    protected $eBook;    /**     * 注意该构造函数注入了电子书接口 EBookInterface     *     * EBookAdapter constructor.     * @param EBookInterface $ebook     */    public function __construct(EBookInterface $eBook)    {        $this-&gt;eBook = $eBook;    }    /**     * 电子书将纸质书接口方法转换为电子书对应方法     *     * @return mixed|void     */    public function open()    {        $this-&gt;eBook-&gt;pressStart();    }    /**     * 纸质书翻页转化为电子书翻页     *     * @return mixed|void     */    public function turnPage()    {        $this-&gt;eBook-&gt;pressNext();    }}// Usage// 老需求:只有纸质书类$book = new Book();$book-&gt;open();$book-&gt;turnPage();// 新需求:改成/增加电子书类的访问, 只需更改 $book 实例就行了, 后面访问不用变$book = new EBookAdapter(new Kindle());$book-&gt;open();$book-&gt;turnPage();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 断点调试（xdebug）</title>
      <link href="/2019/12/03/PHP-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%EF%BC%88xdebug%EF%BC%89/"/>
      <url>/2019/12/03/PHP-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%EF%BC%88xdebug%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="断点调试（xdebug）"><a href="#断点调试（xdebug）" class="headerlink" title="断点调试（xdebug）"></a>断点调试（xdebug）</h2><p>合适的调试器是软件开发中最有用的工具之一，它使你可以跟踪程序执行结果并监视程序堆栈中的信息。xdebug 是一个 PHP 的调试器，它可以被用来在很多 IDE 中做断点调试以及堆栈检查。它还可以像 PHPUnit 和 KCacheGrind 一样，做代码覆盖检查或者程序性能跟踪（Profile &amp; Trace）。</p><p>PHP 代码在 <code>print_r</code> 输出较大的数组时，后面内容可能会出现 <code>...</code> 而看不到，使用 <code>xdebug</code> 就能解决这个问题。</p><p>在本地调试，可以想怎么调试怎么调试，如果线上程序出了 <code>bug</code>，需要在服务器上调试，一般是 <code>改代码 =&gt; 上传 =&gt; 访问，打印输出信息</code>，非常繁琐，而 <code>xdebug</code> 可以远程调试，提高调试的效率。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="安装-amp-使用"><a href="#安装-amp-使用" class="headerlink" title="安装&amp;使用"></a>安装&amp;使用</h3><p>1.PHP 安装 xdebug 扩展（略），<code>xdebug</code> 配置如下：</p><pre><code class="ini"># php.ini[XDebug]; Debug Configxdebug.remote_enable = 1xdebug.idekey = &quot;PHPSTORM&quot;xdebug.remote_handler = &quot;dbgp&quot;; xdebug.remote_connect_back = 1xdebug.remote_host = &quot;host.docker.internal&quot;xdebug.remote_port = 9000xdebug.remote_log = &quot;/var/log/php.xdebug.log&quot;</code></pre><p>2.配置 IDE（PhpStorm），<code>xdebug</code> 有两种调试模式：</p><ul><li>针对单文件（test.php）</li><li>针对项目（xx-api/）</li></ul><p><strong>2.1针对单文件调试</strong></p><p>配置：</p><p><strong>针对项目调试</strong></p><ul><li>配置 Server（<strong>配置目录映射</strong>）</li></ul><p><img src="https://i.loli.net/2019/12/03/SCRD1kTLBwO7Ncv.png" alt=""></p><ul><li>配置 debug 的本地监听端口</li></ul><p><img src="https://i.loli.net/2019/12/03/SZYAyrLo9Ua4cCg.png" alt=""></p><ul><li><p>启动本地监听服务。</p><p>  Run =&gt; Start Listening for PHP Debug Connections 或者点击电话的图标。</p></li><li><p>在 PhpStorm 中打断点</p></li><li><p>打开调试的页面/接口地址+<code>?XDEBUG_SESSION_START=PHPSTORM</code>，目的就是带上在 <code>xdebug</code> 配置中约定的 <code>PHPSTORM</code> 字符串，服务端好知道请求的目的。</p></li><li><p>此时 PhpStorm 会蹦出一个调试栏，可以看到调试信息。<br>  PhpStorm 会拦截当前执行的脚本状态，运行你设置的断点并查看内存中的值。</p></li></ul><p>到这里其实已经大功告成了，但是每次调试都要手动加上参数会不会太麻烦了？<br>是的，这个问题已经有人帮你想好啦，可以去装一个浏览器插件，chrome的插件是 <code>xdebug helper</code>。开启这个插件就不需要在 <code>URL</code> 上加参数了。<br>它的原理是给浏览器设置一个 <code>cookie</code>，Name 是 <code>XDEBUG_SESSION</code>，Key 是 <code>PHPSTORM</code>。</p><p>为什么要设置目录映射？<br>无论那种调试模式，实际上运行的都是 Docker 中的项目和文件，所以开启映射就相当于给 Docker 中的项目打断点，和 PHP 执行的文件就统一了！这样才能成功。</p><p>如果你仍在使用 <code>var_dump()/print_r()</code> 调错，经常会发现自己处于困境，并且仍然找不到解决办法。这时，你该使用调试器了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>xdebug</code> 是一个开放源代码的 PHP 程序调试和性能分析器（即一个 debug 工具），可以用来跟踪，调试和分析 PHP 程序的运行状况。相比<code>echo、print_r()、var_dump()、printf()</code>函数，使用xdebug的效率和精准度更高、也更快捷。</p><p>参考文章：<br><a href="http://laravel-china.github.io/php-the-right-way/#xdebug">xdebug介绍</a><br><a href="https://learnku.com/articles/4090/the-first-step-to-becoming-a-senior-php-programmer-debugging-xdebug-principle">xdebug原理</a><br><a href="https://juejin.im/entry/58fdc9868d6d8100589d826a">xdebug配置</a><br><a href="https://www.cnblogs.com/sunsky303/p/11544520.html">使用xdebug对php做性能分析调优</a><br><a href="https://www.jianshu.com/p/c40a27129aca">PhpStorm + Docker LNMP 中 Xdebug 配置</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Docker </tag>
            
            <tag> xdebug </tag>
            
            <tag> 断点调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 让命令或程序在终端后台运行的方法（Ubuntu/Fedora/CentOS 等一样适用）</title>
      <link href="/2019/07/28/linux-cmd-back-run/"/>
      <url>/2019/07/28/linux-cmd-back-run/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我们在用SecureCRT等终端工具远程登录时，很多时候需要执行一个程序，但是希望程序在用户注销或终端关闭后，能够继续在后台运行。下面介绍几种方法还有注意事项：</p><h2 id="方法1：命令后面加-amp"><a href="#方法1：命令后面加-amp" class="headerlink" title="方法1：命令后面加 &amp;"></a>方法1：命令后面加 &amp;</h2><p>一般情况下在命令后面加&amp;，然后回车执行，就可以了：</p><pre><code>$ node server &amp;</code></pre><h2 id="方法2：运行命令后再按-ctrl-z"><a href="#方法2：运行命令后再按-ctrl-z" class="headerlink" title="方法2：运行命令后再按 ctrl+z"></a>方法2：运行命令后再按 ctrl+z</h2><p>如果你的命令是要执行一个不退出的程序，例如：</p><pre><code>$ node server</code></pre><p>那么它就会一直阻塞控制台，不能输入其他命令了。<br>这时候想让这个程序转到后台运行的话，按ctrl+z便能使其转到后台运行；可以释放控制台做其他操作了。</p><h2 id="方法3：使用-bg-命令"><a href="#方法3：使用-bg-命令" class="headerlink" title="方法3：使用 bg 命令"></a>方法3：使用 bg 命令</h2><p>如果在你进行操作之前，程序早就已经在前台运行了的话，要找回这个程序，先输入jobs，查看要找回的程序，记住左边的编号；再输入bg 编号，搞定。</p><pre><code>$ jobs[1]+  已停止               sudo node server$ bg 1</code></pre><h2 id="特别要注意的一点"><a href="#特别要注意的一点" class="headerlink" title="特别要注意的一点"></a>特别要注意的一点</h2><p><strong>涉及到用户权限的命令，如果要放后台运行，必须先运行这个命令，再 <code>ctrl+z</code> 放到后台。</strong></p><p><strong>不能直接后面加 <code>&amp;</code>：</strong></p><pre><code>$ sudo node server &amp;</code></pre><p><strong>必须去先执行命令：</strong></p><pre><code>$ sudo node server[sudo] password for xxx: 输入密码</code></pre><p><strong>然后再按 <code>ctrl+z</code> 将程序放到后台运行。</strong></p><p>原因很简单，因为在输命令后还需要确认一次密码，想直接加 <code>&amp;</code> 就会让程序自己后台运行的话，岂不大 bug 也？</p><p>这也是网上很多教程文章等等的忽略的一点，忘记提醒刚接触 linux 的读者，让大家走了好多弯路，例如曾经的我，哈哈哈。</p><p><a href="https://segmentfault.com/a/1190000008314935">转载自：segmentfault</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台运行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 安装 Docker 和 Docker-compose</title>
      <link href="/2019/07/27/CentOS7-%E5%AE%89%E8%A3%85-Docker-%E5%92%8C-Docker-compose/"/>
      <url>/2019/07/27/CentOS7-%E5%AE%89%E8%A3%85-Docker-%E5%92%8C-Docker-compose/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS-7-安装-Docker-和-Docker-compose"><a href="#CentOS-7-安装-Docker-和-Docker-compose" class="headerlink" title="CentOS 7 安装 Docker 和 Docker-compose"></a>CentOS 7 安装 Docker 和 Docker-compose</h2><p><a href="https://www.centos.bz/2019/01/centos7-%E5%AE%89%E8%A3%85-docker-%E5%92%8C-docker-compose/">https://www.centos.bz/2019/01/centos7-%E5%AE%89%E8%A3%85-docker-%E5%92%8C-docker-compose/</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> docker-compose </tag>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh 免密码登录服务器</title>
      <link href="/2019/07/27/ssh-no-pwd-login/"/>
      <url>/2019/07/27/ssh-no-pwd-login/</url>
      
        <content type="html"><![CDATA[<h2 id="ssh-免密码登录服务器"><a href="#ssh-免密码登录服务器" class="headerlink" title="ssh 免密码登录服务器"></a>ssh 免密码登录服务器</h2><p>要实现 ssh 登录服务器，首先就要保证客户机（Mac/Pc）和服务器的 ssh 服务是开启的，它们的相关的命令如下：</p><p><strong>linux</strong></p><pre><code># start:开启 stop:关闭 restart:重启 status:查看服务状态$ service sshd start</code></pre><p><strong>Mac</strong></p><pre><code># 1.编辑/etc/sshd_config文件，注释掉 #ForceCommand /usr/local/bin/ssh_session# 2.启动sshd服务$ sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist# 3.停止sshd服务$ sudo launchctl unload -w /System/Library/LaunchDaemons/ssh.plist# 4.查看是否启动$ sudo launchctl list | grep ssh</code></pre><p><strong>其次，就是在本机生成密钥：</strong></p><p>已经存在密钥了则可以不用操作，否则需要在终端下执行命令 <code>ssh-keygen -t rsa</code>，最后把公钥放到服务器上，使用 <code>scp</code> 命令：</p><pre><code>$ scp ~/.ssh/id_rsa.pub aakng@服务器地址:/home/aakng/.ssh/</code></pre><p>然后把 id_rsa.pub 的内容加入到服务器端的默认验证文件 authorized_keys 中：</p><pre><code># 1.先登录到远程服务器，假设登录账号是aakng，/home/aakng/.ssh/和~/.ssh是同个目录$ cd ~/.ssh# 2.将公钥内容加入到authorized_keys文件，没有则新建一个就行。或者将公钥粘贴到authorized_keys中$ cat -n /home/aakng/.ssh/local.id_rsa.pub &gt;&gt; authorized_keys</code></pre><p><strong>其它方法：直接将本机的公钥写入服务器账号下的authorized_keys中（没有测试过），命令如下：</strong></p><pre><code>$ ssh-copy-id -i ~/.ssh/id_rsa.pub aakng@服务器地址</code></pre><p><strong>最后，可以实现免密登录服务器</strong></p><pre><code>$ ssh aakng@服务器地址</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> 免密登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/11/22/hello-world/"/>
      <url>/2018/11/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
